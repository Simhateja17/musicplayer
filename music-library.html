<!-- START OF MUSIC LIBRARY EMBED CODE -->

<style>
/* --- MUSIC LIBRARY THEME VARIABLES --- */
:root {
    --tier1-color: #00BFFF; /* Electric Blue */
    --tier2-color: #FF1493; /* Neon Seduction */
    --tier3-color: #00FFFF; /* Neon Oracle */
    --tier4-color: #FF69B4; /* Neon Muse */
    --background-color: #121212;
    --surface-color: #000000;
    --text-color-primary: #FFFFFF;
    --text-color-secondary: #B3B3B3;
    --success-color: #00FF00;
    --warning-color: #FFA500;
    --error-color: #FF4444;
}

/* Library Container */
#music-library-container {
    background: linear-gradient(135deg, var(--surface-color) 0%, rgba(18, 18, 18, 0.95) 100%);
    color: var(--text-color-primary);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    width: 100%;
    max-width: 1200px;
    border-radius: 20px;
    padding: 24px;
    margin: 20px auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    position: relative;
    min-height: 600px;
}

/* Loading State */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    border-radius: 20px;
}

.loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--text-color-secondary);
    border-top: 3px solid var(--tier1-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Header Section */
.library-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 32px;
    padding-bottom: 20px;
    border-bottom: 2px solid var(--text-color-secondary);
    flex-wrap: wrap;
    gap: 16px;
}

.library-title {
    flex: 1;
}

.library-title h1 {
    font-size: 2rem;
    font-weight: 700;
    margin: 0 0 8px 0;
    background: linear-gradient(45deg, var(--text-color-primary), var(--tier1-color));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.library-subtitle {
    color: var(--text-color-secondary);
    font-size: 0.9rem;
    margin: 0;
}

.user-status {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
}

.tier-indicator {
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.tier-indicator.tier-1 {
    background: linear-gradient(135deg, var(--tier1-color), rgba(0, 191, 255, 0.8));
    color: white;
}

.tier-indicator.tier-2 {
    background: linear-gradient(135deg, var(--tier2-color), rgba(255, 20, 147, 0.8));
    color: white;
}

.tier-indicator.tier-3 {
    background: linear-gradient(135deg, var(--tier3-color), rgba(0, 255, 255, 0.8));
    color: black;
}

.tier-indicator.tier-4 {
    background: linear-gradient(135deg, var(--tier4-color), #FFD700);
    color: black;
}

.tracks-remaining {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 12px 16px;
    text-align: center;
    min-width: 120px;
}

.tracks-remaining.warning {
    border-color: var(--warning-color);
    background: rgba(255, 165, 0, 0.1);
}

.tracks-remaining.error {
    border-color: var(--error-color);
    background: rgba(255, 68, 68, 0.1);
}

.tracks-remaining .count {
    font-size: 1.4rem;
    font-weight: 700;
    margin: 0;
    color: var(--success-color);
}

.tracks-remaining.warning .count {
    color: var(--warning-color);
}

.tracks-remaining.error .count {
    color: var(--error-color);
}

.tracks-remaining .label {
    font-size: 0.75rem;
    color: var(--text-color-secondary);
    margin: 0;
    text-transform: uppercase;
}

/* Search and Filter Section */
.search-filter-section {
    display: flex;
    gap: 16px;
    margin-bottom: 24px;
    flex-wrap: wrap;
}

.search-box {
    flex: 1;
    min-width: 250px;
    position: relative;
}

.search-input {
    width: 100%;
    padding: 14px 20px 14px 50px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 25px;
    color: var(--text-color-primary);
    font-size: 0.95rem;
    transition: all 0.3s ease;
}

.search-input:focus {
    outline: none;
    border-color: var(--tier1-color);
    box-shadow: 0 0 15px rgba(0, 191, 255, 0.3);
}

.search-input::placeholder {
    color: var(--text-color-secondary);
}

.search-icon {
    position: absolute;
    left: 18px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-color-secondary);
    font-size: 1.1rem;
}

.filter-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.filter-btn {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--text-color-secondary);
    padding: 10px 16px;
    border-radius: 20px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.filter-btn:hover,
.filter-btn.active {
    background: var(--tier1-color);
    border-color: var(--tier1-color);
    color: white;
}

/* Song Grid */
.songs-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 20px;
    margin-bottom: 32px;
}

.song-card {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.song-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.2);
}

.song-card.selected {
    border-color: var(--success-color);
    background: linear-gradient(135deg, rgba(0, 255, 0, 0.1), rgba(0, 255, 0, 0.05));
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
}

.song-card.disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.song-card.disabled:hover {
    transform: none;
    box-shadow: none;
}

.song-info {
    margin-bottom: 16px;
}

.song-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin: 0 0 8px 0;
    color: var(--text-color-primary);
    line-height: 1.3;
}

.song-artist {
    font-size: 0.9rem;
    color: var(--text-color-secondary);
    margin: 0;
}

.song-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
}

.add-btn {
    background: linear-gradient(135deg, var(--success-color), rgba(0, 255, 0, 0.8));
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.add-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
}

.add-btn.added {
    background: linear-gradient(135deg, var(--tier1-color), rgba(0, 191, 255, 0.8));
}

.add-btn:disabled {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-color-secondary);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.preview-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--text-color-secondary);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1.2rem;
}

.preview-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    color: var(--text-color-primary);
}

/* Selected Songs Summary */
.selected-summary {
    position: sticky;
    bottom: 0;
    background: linear-gradient(135deg, rgba(0, 191, 255, 0.1), rgba(0, 191, 255, 0.05));
    border: 1px solid rgba(0, 191, 255, 0.3);
    border-radius: 12px;
    padding: 20px;
    margin-top: 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 16px;
}

.summary-info h3 {
    font-size: 1.1rem;
    font-weight: 600;
    margin: 0 0 4px 0;
    color: var(--tier1-color);
}

.summary-info p {
    font-size: 0.9rem;
    color: var(--text-color-secondary);
    margin: 0;
}

.summary-actions {
    display: flex;
    gap: 12px;
}

.clear-selection-btn {
    background: var(--error-color);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.clear-selection-btn:hover {
    background: #ff6666;
}

.save-selection-btn {
    background: linear-gradient(135deg, var(--success-color), rgba(0, 255, 0, 0.8));
    color: white;
    border: none;
    padding: 10px 24px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.save-selection-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-color-secondary);
}

.empty-state h3 {
    font-size: 1.4rem;
    margin: 0 0 12px 0;
    color: var(--text-color-primary);
}

.empty-state p {
    font-size: 0.95rem;
    margin: 0;
    line-height: 1.5;
}

/* Error States */
.error-message {
    background: linear-gradient(135deg, rgba(255, 68, 68, 0.1), rgba(255, 68, 68, 0.05));
    border: 1px solid rgba(255, 68, 68, 0.3);
    border-radius: 8px;
    padding: 16px;
    margin: 16px 0;
    color: var(--error-color);
    text-align: center;
}

.hidden {
    display: none !important;
}

/* Responsive Design */
@media (max-width: 768px) {
    #music-library-container {
        padding: 16px;
        margin: 10px;
        max-width: none;
    }
    
    .library-header {
        flex-direction: column;
        align-items: stretch;
    }
    
    .library-title h1 {
        font-size: 1.6rem;
        text-align: center;
    }
    
    .user-status {
        justify-content: center;
    }
    
    .search-filter-section {
        flex-direction: column;
    }
    
    .search-box {
        min-width: auto;
    }
    
    .filter-buttons {
        justify-content: center;
    }
    
    .songs-grid {
        grid-template-columns: 1fr;
    }
    
    .selected-summary {
        flex-direction: column;
        text-align: center;
    }
    
    .summary-actions {
        width: 100%;
        justify-content: center;
    }
}

/* Pulse animation for loading states */
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.loading-pulse {
    animation: pulse 1.5s ease-in-out infinite;
}
</style>

<!-- MUSIC LIBRARY HTML STRUCTURE -->
<div id="music-library-container">
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    
    <!-- Error Message -->
    <div class="error-message hidden" id="errorMessage">
        Failed to load music library. Please refresh the page or contact support.
    </div>
    
    <!-- Library Header -->
    <div class="library-header">
        <div class="library-title">
            <h1>Music Library</h1>
            <p class="library-subtitle">Discover and add tracks to your personal playlist</p>
        </div>
        <div class="user-status">
            <div class="tier-indicator" id="tierIndicator">
                Loading...
            </div>
            <div class="tracks-remaining" id="tracksRemaining">
                <p class="count" id="remainingCount">-</p>
                <p class="label">Remaining</p>
            </div>
        </div>
    </div>
    
    <!-- Search and Filter Section -->
    <div class="search-filter-section">
        <div class="search-box">
            <div class="search-icon">üîç</div>
            <input 
                type="text" 
                class="search-input" 
                id="searchInput" 
                placeholder="Search for songs or artists..."
            >
        </div>
        <div class="filter-buttons">
            <button class="filter-btn active" id="filterAll">All Songs</button>
            <button class="filter-btn" id="filterSelected">Selected</button>
            <button class="filter-btn" id="filterAvailable">Available</button>
        </div>
    </div>
    
    <!-- Songs Grid -->
    <div class="songs-grid" id="songsGrid">
        <!-- Songs will be loaded here -->
    </div>
    
    <!-- Empty State -->
    <div class="empty-state hidden" id="emptyState">
        <h3>No songs found</h3>
        <p>Try adjusting your search terms or filters to find more tracks.</p>
    </div>
    
    <!-- Selected Songs Summary -->
    <div class="selected-summary hidden" id="selectedSummary">
        <div class="summary-info">
            <h3 id="summaryTitle">Songs Selected This Session</h3>
            <p id="summaryText">You've selected 0 songs to add to your playlist.</p>
        </div>
        <div class="summary-actions">
            <button class="clear-selection-btn" id="clearSelectionBtn">Clear Selection</button>
            <button class="save-selection-btn" id="saveSelectionBtn">Save to Playlist</button>
        </div>
    </div>
</div>

<!-- MUSIC LIBRARY JAVASCRIPT -->
<script>
document.addEventListener('DOMContentLoaded', async () => {
    // Configuration
    const TIER_CONFIG = {
        1: {
            name: 'Electric Blue',
            color: '#00BFFF',
            initialTracks: 10,
            monthlyTracks: 5,
            className: 'tier-1'
        },
        2: {
            name: 'Neon Seduction',
            color: '#FF1493',
            initialTracks: 20,
            monthlyTracks: 10,
            className: 'tier-2'
        },
        3: {
            name: 'Neon Oracle',
            color: '#00FFFF',
            initialTracks: 30,
            monthlyTracks: 15,
            className: 'tier-3'
        },
        4: {
            name: 'Neon Muse',
            color: '#FF69B4',
            initialTracks: -1, // Unlimited
            monthlyTracks: -1,
            className: 'tier-4'
        }
    };

    // DOM Elements
    const loadingOverlay = document.getElementById('loadingOverlay');
    const errorMessage = document.getElementById('errorMessage');
    const tierIndicator = document.getElementById('tierIndicator');
    const tracksRemaining = document.getElementById('tracksRemaining');
    const remainingCount = document.getElementById('remainingCount');
    const searchInput = document.getElementById('searchInput');
    const filterAll = document.getElementById('filterAll');
    const filterSelected = document.getElementById('filterSelected');
    const filterAvailable = document.getElementById('filterAvailable');
    const songsGrid = document.getElementById('songsGrid');
    const emptyState = document.getElementById('emptyState');
    const selectedSummary = document.getElementById('selectedSummary');
    const summaryTitle = document.getElementById('summaryTitle');
    const summaryText = document.getElementById('summaryText');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const saveSelectionBtn = document.getElementById('saveSelectionBtn');

    // State
    let currentUser = null;
    let allSongs = [];
    let userPlaylist = [];
    let selectedSongs = new Set();
    let currentFilter = 'all';
    let searchTerm = '';

    // API Base URL
    function getApiBaseUrl() {
        // Local development
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            return 'http://localhost:3000';
        }
        // Production Azure backend
        return 'https://music-player-hadbg3c8cwazh4gm.canadacentral-01.azurewebsites.net';
    }

    // Get current user from Memberstack
    async function getCurrentUser() {
        try {
            if (typeof window.$memberstackDom === 'undefined') {
                throw new Error('Memberstack not loaded');
            }
            
            const member = await window.$memberstackDom.getCurrentMember();
            if (!member) {
                throw new Error('No user logged in');
            }
            
            return {
                id: member.id,
                email: member.email,
                tier: getTierFromMemberstack(member),
                planConnections: member.planConnections
            };
        } catch (error) {
            console.error('Error getting current user:', error);
            throw error;
        }
    }

    // Extract tier information from Memberstack data
    function getTierFromMemberstack(member) {
        if (member.planConnections && member.planConnections.length > 0) {
            const planId = member.planConnections[0].planId;
            
            // Actual Plan IDs from client's Memberstack dashboard
            const planMapping = {
                'pln_tier-1-cq5u0dlz': 1,              // Electric Blue
                'pln_tier-2-hn4j0op9': 2,              // Neon Seduction  
                'pln_tier-3-kx5v0dyk': 3,              // Neon Oracle
                'pln_tier-4-neon-muse-hg1he0sox': 4   // Neon Muse
            };
            
            return planMapping[planId] || 1; // Default to tier 1 if not found
        }
        
        if (member.customFields && member.customFields.tier) {
            return parseInt(member.customFields.tier);
        }
        
        return 1; // Default tier
    }

    // Fetch all songs from database
    async function fetchAllSongs() {
        try {
            const response = await fetch(`${getApiBaseUrl()}/api/songs`);
            if (!response.ok) throw new Error('Failed to fetch songs');
            return await response.json();
        } catch (error) {
            console.error('Error fetching songs:', error);
            return [];
        }
    }

    // Fetch user playlist
    async function fetchUserPlaylist(userId) {
        try {
            const response = await fetch(`${getApiBaseUrl()}/api/user-playlist/${userId}`);
            if (!response.ok) throw new Error('Failed to fetch playlist');
            return await response.json();
        } catch (error) {
            console.error('Error fetching playlist:', error);
            return [];
        }
    }

    // Add songs to user playlist
    async function addSongsToPlaylist(userId, songIds) {
        try {
            const response = await fetch(`${getApiBaseUrl()}/api/user-playlist/bulk`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    userId,
                    songIds,
                    tierLevel: currentUser.tier
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Failed to add songs');
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error adding songs:', error);
            throw error;
        }
    }

    // Calculate remaining tracks
    function calculateRemainingTracks() {
        if (!currentUser) return 0;
        
        const tierConfig = TIER_CONFIG[currentUser.tier];
        if (tierConfig.initialTracks === -1) return -1; // Unlimited
        
        const maxTracks = tierConfig.initialTracks + (tierConfig.monthlyTracks * getMonthsSinceSignup());
        return Math.max(0, maxTracks - userPlaylist.length);
    }

    // Get months since signup (placeholder)
    function getMonthsSinceSignup() {
        return 0; // This would be calculated based on user signup date
    }

    // Filter songs based on current filters
    function getFilteredSongs() {
        let filtered = [...allSongs];
        
        // Apply search filter
        if (searchTerm) {
            const term = searchTerm.toLowerCase();
            filtered = filtered.filter(song => 
                song.title.toLowerCase().includes(term) || 
                song.artist.toLowerCase().includes(term)
            );
        }
        
        // Apply category filter
        const playlistIds = new Set(userPlaylist.map(song => song.id));
        
        switch (currentFilter) {
            case 'selected':
                filtered = filtered.filter(song => selectedSongs.has(song.id));
                break;
            case 'available':
                filtered = filtered.filter(song => !playlistIds.has(song.id));
                break;
            default:
                // 'all' - no additional filtering
                break;
        }
        
        return filtered;
    }

    // Render songs grid
    function renderSongs() {
        const filteredSongs = getFilteredSongs();
        const playlistIds = new Set(userPlaylist.map(song => song.id));
        const remainingTracks = calculateRemainingTracks();
        const canAddMore = remainingTracks === -1 || remainingTracks > 0;
        
        if (filteredSongs.length === 0) {
            songsGrid.innerHTML = '';
            emptyState.classList.remove('hidden');
            return;
        }
        
        emptyState.classList.add('hidden');
        
        songsGrid.innerHTML = filteredSongs.map(song => {
            const isInPlaylist = playlistIds.has(song.id);
            const isSelected = selectedSongs.has(song.id);
            const isDisabled = !canAddMore && !isSelected && !isInPlaylist;
            
            let cardClass = 'song-card';
            if (isSelected) cardClass += ' selected';
            if (isDisabled) cardClass += ' disabled';
            
            let buttonText = 'Add to Playlist';
            let buttonClass = 'add-btn';
            let buttonDisabled = '';
            
            if (isInPlaylist) {
                buttonText = 'Already Added';
                buttonClass += ' added';
                buttonDisabled = 'disabled';
            } else if (isSelected) {
                buttonText = 'Selected ‚úì';
                buttonClass += ' added';
            } else if (isDisabled) {
                buttonText = 'Limit Reached';
                buttonDisabled = 'disabled';
            }
            
            return `
                <div class="${cardClass}" data-song-id="${song.id}">
                    <div class="song-info">
                        <h3 class="song-title">${song.title}</h3>
                        <p class="song-artist">${song.artist}</p>
                    </div>
                    <div class="song-actions">
                        <button 
                            class="${buttonClass}" 
                            onclick="toggleSongSelection(${song.id})"
                            ${buttonDisabled}
                        >
                            ${buttonText}
                        </button>
                        <button 
                            class="preview-btn" 
                            onclick="previewSong('${song.streaming_url}')"
                            title="Preview song"
                        >
                            ‚ñ∂
                        </button>
                    </div>
                </div>
            `;
        }).join('');
    }

    // Toggle song selection
    function toggleSongSelection(songId) {
        const playlistIds = new Set(userPlaylist.map(song => song.id));
        
        // Don't allow toggling if already in playlist
        if (playlistIds.has(songId)) return;
        
        const remainingTracks = calculateRemainingTracks();
        
        if (selectedSongs.has(songId)) {
            // Remove from selection
            selectedSongs.delete(songId);
        } else {
            // Add to selection
            if (remainingTracks !== -1 && selectedSongs.size >= remainingTracks) {
                alert(`You can only select ${remainingTracks} more track${remainingTracks !== 1 ? 's' : ''} this month.`);
                return;
            }
            selectedSongs.add(songId);
        }
        
        updateUI();
    }

    // Preview song (placeholder)
    function previewSong(url) {
        console.log('Preview song:', url);
        // Implement audio preview functionality
        // Could use HTML5 audio element or integrate with existing player
    }

    // Update filter buttons
    function updateFilterButtons() {
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        switch (currentFilter) {
            case 'selected':
                filterSelected.classList.add('active');
                break;
            case 'available':
                filterAvailable.classList.add('active');
                break;
            default:
                filterAll.classList.add('active');
                break;
        }
    }

    // Update selected summary
    function updateSelectedSummary() {
        if (selectedSongs.size === 0) {
            selectedSummary.classList.add('hidden');
            return;
        }
        
        selectedSummary.classList.remove('hidden');
        summaryTitle.textContent = `${selectedSongs.size} Song${selectedSongs.size !== 1 ? 's' : ''} Selected`;
        summaryText.textContent = `You've selected ${selectedSongs.size} song${selectedSongs.size !== 1 ? 's' : ''} to add to your playlist.`;
    }

    // Update remaining tracks display
    function updateRemainingTracksDisplay() {
        const remaining = calculateRemainingTracks();
        
        if (remaining === -1) {
            remainingCount.textContent = '‚àû';
            tracksRemaining.classList.remove('warning', 'error');
        } else {
            remainingCount.textContent = remaining;
            
            // Update styling based on remaining count
            tracksRemaining.classList.remove('warning', 'error');
            if (remaining === 0) {
                tracksRemaining.classList.add('error');
            } else if (remaining <= 3) {
                tracksRemaining.classList.add('warning');
            }
        }
    }

    // Main UI update function
    function updateUI() {
        renderSongs();
        updateFilterButtons();
        updateSelectedSummary();
        updateRemainingTracksDisplay();
    }

    // Save selected songs
    async function saveSelectedSongs() {
        if (selectedSongs.size === 0) return;
        
        try {
            saveSelectionBtn.disabled = true;
            saveSelectionBtn.textContent = 'Saving...';
            
            await addSongsToPlaylist(currentUser.id, Array.from(selectedSongs));
            
            // Refresh user playlist
            userPlaylist = await fetchUserPlaylist(currentUser.id);
            
            // Clear selection
            selectedSongs.clear();
            
            // Update UI
            updateUI();
            
            alert('Songs added to your playlist successfully!');
            
        } catch (error) {
            console.error('Error saving songs:', error);
            alert('Failed to save songs: ' + error.message);
        } finally {
            saveSelectionBtn.disabled = false;
            saveSelectionBtn.textContent = 'Save to Playlist';
        }
    }

    // Clear selection
    function clearSelection() {
        selectedSongs.clear();
        updateUI();
    }

    // Initialize library
    async function initializeLibrary() {
        try {
            loadingOverlay.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            
            // Get current user
            currentUser = await getCurrentUser();
            
            // Update tier indicator
            const tierConfig = TIER_CONFIG[currentUser.tier];
            tierIndicator.textContent = `Tier ${currentUser.tier}: ${tierConfig.name}`;
            tierIndicator.className = `tier-indicator ${tierConfig.className}`;
            
            // Fetch data
            const [songs, playlist] = await Promise.all([
                fetchAllSongs(),
                fetchUserPlaylist(currentUser.id)
            ]);
            
            allSongs = songs;
            userPlaylist = playlist;
            
            // Initial UI update
            updateUI();
            
        } catch (error) {
            console.error('Error initializing library:', error);
            errorMessage.classList.remove('hidden');
        } finally {
            loadingOverlay.classList.add('hidden');
        }
    }

    // Event Listeners
    searchInput.addEventListener('input', (e) => {
        searchTerm = e.target.value;
        updateUI();
    });

    filterAll.addEventListener('click', () => {
        currentFilter = 'all';
        updateUI();
    });

    filterSelected.addEventListener('click', () => {
        currentFilter = 'selected';
        updateUI();
    });

    filterAvailable.addEventListener('click', () => {
        currentFilter = 'available';
        updateUI();
    });

    clearSelectionBtn.addEventListener('click', clearSelection);
    saveSelectionBtn.addEventListener('click', saveSelectedSongs);

    // Make functions globally available
    window.toggleSongSelection = toggleSongSelection;
    window.previewSong = previewSong;

    // Initialize
    await initializeLibrary();
});
</script>

<!-- END OF MUSIC LIBRARY EMBED CODE -->
